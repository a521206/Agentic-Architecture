<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comparative Analysis and Pattern Interrelationships</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
      body {
          font-family: 'Inter', sans-serif;
      }
      /* Custom styles for gradients and shadows not easily achievable with Tailwind alone */
      .header-gradient {
          background-image: linear-gradient(to right, #e0f2fe, #bfdbfe, #dbeafe);
      }
      /* Custom gradients for section headers */
      .section-header-blue {
          background-image: linear-gradient(to right, #60a5fa, #3b82f6, #2563eb);
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
      }
      .section-header-purple {
          background-image: linear-gradient(to right, #a78bfa, #8b5cf6, #7c3aed);
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
      }
      .section-header-green {
          background-image: linear-gradient(to right, #4ade80, #22c55e, #16a34a);
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
      }
      .section-header-yellow {
          background-image: linear-gradient(to right, #fcd34d, #fbbf24, #f59e0b);
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
      }
      .content-block-bg {
          background: rgba(255, 255, 255, 0.95);
          backdrop-filter: blur(8px);
          -webkit-backdrop-filter: blur(8px);
      }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">
  <div class="max-w-6xl mx-auto px-4 py-8">
    <!-- Navigation -->
    <div class="flex flex-col md:flex-row justify-between items-center mb-10 gap-3">
      <a href="agentic-design-pattern.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 font-semibold py-2 px-4 rounded-lg bg-blue-50 hover:bg-blue-100 transition duration-300 shadow-sm border border-blue-200">
        <i class="fas fa-arrow-left mr-2"></i> Previous: Design Patterns
      </a>
      <a href="../../index.html" class="inline-flex items-center text-gray-700 hover:text-blue-700 font-semibold py-2 px-4 rounded-lg bg-gray-100 hover:bg-gray-200 transition duration-300 shadow-sm border border-gray-300">
        <i class="fas fa-home mr-2"></i> Home
      </a>
      <a href="orchestrating-agentic-systems.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 font-semibold py-2 px-4 rounded-lg bg-blue-50 hover:bg-blue-100 transition duration-300 shadow-sm border border-blue-200">
        Next: Orchestration <i class="fas fa-arrow-right ml-2"></i>
      </a>
    </div>
    
    <!-- Header -->
    <header class="header-gradient rounded-3xl shadow-2xl p-12 mb-16 text-center border border-blue-300 transform transition-all duration-500 hover:scale-[1.01] hover:shadow-3xl">
      <h1 class="text-5xl md:text-6xl font-extrabold text-blue-900 mb-5 tracking-tight drop-shadow-lg leading-tight">Comparative Analysis and Pattern Interrelationships</h1>
      <p class="text-2xl text-blue-700 font-medium opacity-90">Understanding the nuances and relationships between agentic design patterns is key to effective system architecture. While distinct, these patterns often exhibit synergies and form layered structures within complex agentic systems.</p>
    </header>

    <!-- Nav Tiles -->
    <nav class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-8 mb-16">
      <a href="#layering" class="bg-gradient-to-br from-blue-50 to-blue-100 hover:from-blue-100 hover:to-blue-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center text-center shadow-lg ring-1 ring-blue-200 hover:ring-blue-300 transform hover:scale-105">
        <div class="text-5xl text-blue-600 mb-3"><i class="fas fa-layer-group"></i></div>
        <h3 class="font-extrabold text-xl mb-2 text-blue-800">Layering and Hierarchy</h3>
        <p class="text-gray-600 text-sm">A high-level Planning agent may coordinate Multi-Agent teams</p>
      </a>

      <a href="#interdependencies" class="bg-gradient-to-br from-purple-50 to-purple-100 hover:from-purple-100 hover:to-purple-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center text-center shadow-lg ring-1 ring-purple-200 hover:ring-purple-300 transform hover:scale-105">
        <div class="text-5xl text-purple-600 mb-3"><i class="fas fa-link"></i></div>
        <h3 class="font-extrabold text-xl mb-2 text-purple-800">Interdependencies</h3>
        <p class="text-gray-600 text-sm">Pattern relationships and synergies</p>
      </a>

      <a href="#reasoning" class="bg-gradient-to-br from-green-50 to-green-100 hover:from-green-100 hover:to-green-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center text-center shadow-lg ring-1 ring-green-200 hover:ring-green-300 transform hover:scale-105">
        <div class="text-5xl text-green-600 mb-3"><i class="fas fa-brain"></i></div>
        <h3 class="font-extrabold text-xl mb-2 text-green-800">Core Reasoning</h3>
        <p class="text-gray-600 text-sm">Different approaches to agent decision-making</p>
      </a>

      <a href="#flexibility" class="bg-gradient-to-br from-yellow-50 to-yellow-100 hover:from-yellow-100 hover:to-yellow-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center text-center shadow-lg ring-1 ring-yellow-200 hover:ring-yellow-300 transform hover:scale-105">
        <div class="text-5xl text-yellow-600 mb-3"><i class="fas fa-random"></i></div>
        <h3 class="font-extrabold text-xl mb-2 text-yellow-800">Flexibility vs Structure</h3>
        <p class="text-gray-600 text-sm">Balancing adaptability with predictability</p>
      </a>
    </nav>

    <!-- Layering and Hierarchy Section -->
    <section id="layering" class="mb-20">
      <div class="mb-8">
        <h2 class="text-3xl font-extrabold section-header-blue bg-clip-text text-transparent flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-blue-200">
            <i class="fas fa-layer-group text-blue-600"></i> Layering and Hierarchy
        </h2>
      </div>
      <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-blue-100 p-10 mb-10 border border-blue-200 backdrop-blur-sm">
        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
            <i class="fas fa-info-circle text-blue-500"></i> Description
          </h3>
          <p class="text-gray-700 leading-relaxed">This pattern describes how different agentic patterns can be organized into a <strong>hierarchical structure</strong>, where higher-level agents orchestrate and manage the operations of lower-level, specialized agents. This interrelationship enables the creation of highly complex systems by delegating tasks and maintaining clear lines of responsibility, facilitating modularity and scalability.</p>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
            <i class="fas fa-puzzle-piece text-blue-500"></i> Key Components
          </h3>
          <ul class="space-y-4 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">High-level Planning Agent:</strong> Defines the overall strategy and sequence of operations for lower layers.</li>
            <li><strong class="text-gray-900">Specialized Agents:</strong> Execute specific tasks or sub-processes as directed by higher-level agents.</li>
            <li><strong class="text-gray-900">Communication Protocol:</strong> Standardized messages for inter-layer coordination and data exchange.</li>
            <li><strong class="text-gray-900">State Management:</strong> Mechanisms to track progress and context across different layers of the hierarchy.</li>
          </ul>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
            <i class="fas fa-code text-blue-500"></i> Implementation
          </h3>
          <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>class HierarchicalSystem {
    constructor() {
        this.planningAgent = new PlanningAgent(); // Assuming PlanningAgent is defined elsewhere
        this.specializedAgents = new Map();
        // Example: Add a mock specialized agent
        this.specializedAgents.set('data_processing', { 
            execute: async (step) => { 
                console.log(`Processing data for step: ${step.id}`); 
                return `Processed data for ${step.id}`; 
            }
        });
        this.specializedAgents.set('report_generation', { 
            execute: async (step) => { 
                console.log(`Generating report for step: ${step.id}`); 
                return `Report generated for ${step.id}`; 
            }
        });
    }

    async executeTask(task) {
        console.log(`Executing main task: ${task.name}`);
        // Mocking PlanningAgent.createPlan
        const plan = await (async () => {
            console.log(`Planning for task: ${task.name}`);
            return {
                steps: [
                    { id: 'step1_data', type: 'data_processing', input: task.data },
                    { id: 'step2_report', type: 'report_generation', input: 'processed_data' }
                ]
            };
        })();

        const results = new Map();
        
        for (const step of plan.steps) {
            const agent = this.specializedAgents.get(step.type);
            if (agent) {
                const stepResult = await agent.execute(step);
                results.set(step.id, stepResult);
                console.log(`Step ${step.id} (${step.type}) completed with result: ${stepResult}`);
            } else {
                console.error(`No specialized agent found for type: ${step.type}`);
            }
        }
        
        // Mocking PlanningAgent.synthesizeResults
        const finalResult = await (async () => {
            console.log(`Synthesizing results: ${JSON.stringify(Array.from(results.entries()))}`);
            return `Task ${task.name} completed. Final results: ${Array.from(results.values()).join(', ')}`;
        })();

        return finalResult;
    }
}

// Mock PlanningAgent for the example
class PlanningAgent {
    async createPlan(task) {
        console.log(`PlanningAgent creating plan for: ${task.name}`);
        // In a real scenario, this would use an LLM or complex logic
        return {
            steps: [
                { id: 'subtask1', type: 'data_processing', data: 'initial_data' },
                { id: 'subtask2', type: 'report_generation', data: 'intermediate_data' }
            ]
        };
    }

    async synthesizeResults(results) {
        console.log('PlanningAgent synthesizing results...');
        // In a real scenario, this would combine results into a coherent final output
        return `Final synthesized result: ${JSON.stringify(Array.from(results.entries()))}`;
    }
}

// Example Usage
async function runHierarchicalSystemExample() {
    console.log("Starting HierarchicalSystem Example...");
    const system = new HierarchicalSystem();
    const result = await system.executeTask({ name: 'Generate Quarterly Report', data: 'Q1_sales_data' });
    console.log("Overall Task Result:", result);
}

// Execute the example
if (typeof globalThis.process === 'undefined' || !globalThis.process.versions || !globalThis.process.versions.node) {
    runHierarchicalSystemExample(); // Browser environment
} else {
    runHierarchicalSystemExample(); // Node.js environment
}
</code></pre>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
            <i class="fas fa-lightbulb text-blue-500"></i> Use Cases
          </h3>
          <ul class="space-y-3 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Complex Workflow Orchestration:</strong> Breaking down large, multi-stage processes into manageable sub-tasks handled by specialized agents.</li>
            <li><strong class="text-gray-900">Multi-Agent Collaboration Systems:</strong> Where a master agent directs a team of worker agents to achieve a common goal.</li>
            <li><strong class="text-gray-900">Enterprise-Scale Automation:</strong> Structuring automated processes where different departments or functionalities are managed by distinct agent layers.</li>
            <li><strong class="text-gray-900">Distributed Problem Solving:</strong> Coordinating multiple AI agents across different domains, with a central agent overseeing the overall solution.</li>
          </ul>
        </div>

        <div>
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
            <i class="fas fa-project-diagram text-blue-500"></i> Related Patterns
          </h3>
          <ul class="space-y-2 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Planning Pattern:</strong> Often serves as the high-level coordinator in a layered system, defining the sequence of operations.</li>
            <li><strong class="text-gray-900">Tool Use Pattern:</strong> Specialized agents at lower layers frequently implement the Tool Use pattern to interact with external systems.</li>
            <li><strong class="text-gray-900">Reflection Pattern:</strong> Can be applied at various levels of the hierarchy for self-correction and optimization of individual agents or the entire system.</li>
            <li><strong class="text-gray-900">Multi-Agent Pattern:</strong> Directly relates to layering as it defines how multiple agents (often organized hierarchically) interact.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Interdependencies Section -->
    <section id="interdependencies" class="mb-20">
      <div class="mb-8">
        <h2 class="text-3xl font-extrabold section-header-purple bg-clip-text text-transparent flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-purple-200">
            <i class="fas fa-link text-purple-600"></i> Interdependencies
        </h2>
      </div>
      <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-purple-100 p-10 mb-10 border border-purple-200 backdrop-blur-sm">
        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
            <i class="fas fa-info-circle text-purple-500"></i> Description
          </h3>
          <p class="text-gray-700 leading-relaxed">This section explores the crucial <strong>relationships and dependencies</strong> between different agentic patterns. Understanding these interdependencies is vital because patterns rarely operate in isolation; instead, they combine and rely on each other to form sophisticated, synergistic systems, enabling capabilities greater than the sum of their individual parts.</p>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
            <i class="fas fa-puzzle-piece text-purple-500"></i> Key Components
          </h3>
          <ul class="space-y-4 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Pattern Dependencies:</strong> Explicit or implicit relationships where one pattern requires the output or state of another.</li>
            <li><strong class="text-gray-900">Synergy Points:</strong> Interactions where combining patterns yields enhanced capabilities or efficiency.</li>
            <li><strong class="text-gray-900">Communication Channels:</strong> Interfaces and protocols for patterns to exchange information and control.</li>
            <li><strong class="text-gray-900">State Sharing:</strong> Mechanisms for patterns to access and update common context or knowledge.</li>
          </ul>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
            <i class="fas fa-code text-purple-500"></i> Implementation
          </h3>
          <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>class PatternOrchestrator {
    constructor() {
        this.patterns = new Map(); // Maps pattern IDs to pattern instances
        this.dependencies = new Map(); // Maps pattern IDs to their dependency IDs
    }

    addPattern(patternId, patternInstance, dependencies = []) {
        this.patterns.set(patternId, patternInstance);
        this.dependencies.set(patternId, dependencies);
    }

    async executePattern(patternId, initialContext = {}) {
        const pattern = this.patterns.get(patternId);
        if (!pattern) {
            throw new Error(`Pattern with ID ${patternId} not found.`);
        }

        const deps = this.dependencies.get(patternId) || [];
        
        // Recursively execute dependencies first
        const depResults = {};
        for (const depId of deps) {
            depResults[depId] = await this.executePattern(depId, initialContext); // Pass context down
        }
        
        // Merge dependency results into the context for the current pattern
        const currentContext = { ...initialContext, ...depResults };

        console.log(`Executing pattern '${patternId}' with context:`, currentContext);
        // Assuming each pattern has an 'execute' method that takes a context
        const result = await pattern.execute(currentContext);
        console.log(`Pattern '${patternId}' completed with result:`, result);
        return result;
    }
}

// Mock Pattern classes for demonstration
class MockPattern {
    constructor(id) {
        this.id = id;
    }
    async execute(context) {
        // Simulate some work based on context
        await new Promise(resolve => setTimeout(resolve, 100)); // Simulate async operation
        return { [`${this.id}_output`]: `processed_${context.input_data || 'default'}` };
    }
}

// Example Usage
async function runInterdependenciesExample() {
    console.log("Starting Interdependencies Example...");
    const orchestrator = new PatternOrchestrator();

    // Define patterns and their dependencies
    const dataPrepPattern = new MockPattern('data_preparation');
    const analysisPattern = new MockPattern('data_analysis');
    const reportGenPattern = new MockPattern('report_generation');

    orchestrator.addPattern('data_preparation', dataPrepPattern);
    orchestrator.addPattern('data_analysis', analysisPattern, ['data_preparation']); // Analysis depends on data_preparation
    orchestrator.addPattern('report_generation', reportGenPattern, ['data_analysis']); // Report depends on data_analysis

    try {
        const finalResult = await orchestrator.executePattern('report_generation', { input_data: 'raw_sales_records' });
        console.log("Final Orchestration Result:", finalResult);
    } catch (error) {
        console.error("Orchestration failed:", error);
    }
}

// Execute the example
if (typeof globalThis.process === 'undefined' || !globalThis.process.versions || !globalThis.process.versions.node) {
    runInterdependenciesExample(); // Browser environment
} else {
    runInterdependenciesExample(); // Node.js environment
}
</code></pre>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
            <i class="fas fa-lightbulb text-purple-500"></i> Use Cases
          </h3>
          <ul class="space-y-3 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Complex System Design:</strong> Architecting systems where the successful execution of one agentic function relies on the output or state of another.</li>
            <li><strong class="text-gray-900">Pattern Composition:</strong> Building highly specialized agents by combining simpler, interdependent patterns (e.g., a "Research Agent" composed of Planning, Tool Use, and Reflection).</li>
            <li><strong class="text-gray-900">System Optimization:</strong> Identifying critical path dependencies to optimize performance and resource allocation in multi-pattern workflows.</li>
            <li><strong class="text-gray-900">Architecture Planning:</strong> Visualizing and managing the flow of control and data between different agentic components during system design.</li>
          </ul>
        </div>

        <div>
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
            <i class="fas fa-project-diagram text-purple-500"></i> Related Patterns
          </h3>
          <ul class="space-y-2 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Layering Pattern:</strong> Often defines the hierarchical dependencies within a system, which are a form of interdependency.</li>
            <li><strong class="text-gray-900">Routing Pattern:</strong> Determines which pattern or agent should be invoked next, based on the output or state of a preceding pattern.</li>
            <li><strong class="text-gray-900">Reflection Pattern:</strong> Can analyze and optimize the flow and efficiency of interdependent patterns.</li>
            <li><strong class="text-gray-900">Prompt Chaining Pattern:</strong> Explicitly demonstrates sequential interdependencies between LLM prompts to achieve a complex goal.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Core Reasoning Section -->
    <section id="reasoning" class="mb-20">
      <div class="mb-8">
        <h2 class="text-3xl font-extrabold section-header-green bg-clip-text text-transparent flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-green-200">
            <i class="fas fa-brain text-green-600"></i> Core Reasoning
        </h2>
      </div>
      <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-green-100 p-10 mb-10 border border-green-200 backdrop-blur-sm">
        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
            <i class="fas fa-info-circle text-green-500"></i> Description
          </h3>
          <p class="text-gray-700 leading-relaxed">This section provides a <strong>comparative analysis of fundamental approaches</strong> to agent decision-making and problem-solving. Understanding the differences between patterns like <strong>ReAct</strong> and <strong>Plan-and-Execute</strong> is crucial for selecting the most appropriate cognitive foundation for an agent, balancing reactivity with structured foresight.</p>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
            <i class="fas fa-puzzle-piece text-green-500"></i> Key Components
          </h3>
          <ul class="space-y-4 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Reasoning Strategy:</strong> The specific methodology an agent uses to process information and derive decisions.</li>
            <li><strong class="text-gray-900">Action Selection:</strong> How the agent chooses and executes actions based on its reasoning.</li>
            <li><strong class="text-gray-900">State Management:</strong> How internal context and observations are maintained during the reasoning process.</li>
            <li><strong class="text-gray-900">Feedback Loop:</strong> Mechanisms for agents to learn from outcomes and refine their reasoning.</li>
          </ul>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
            <i class="fas fa-code text-green-500"></i> Implementation
          </h3>
          <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>class ReasoningAgent {
    constructor(strategy) {
        this.strategy = strategy;
        this.state = { history: [] }; // Initialize state with history
        console.log(`Agent initialized with strategy: ${this.strategy}`);
    }

    async think(input) {
        console.log(`Thinking with input: ${input}`);
        this.state.history.push({ type: 'input', value: input });

        let result;
        switch(this.strategy) {
            case 'react':
                result = await this.reactReasoning(input);
                break;
            case 'plan-and-execute':
                result = await this.planAndExecute(input);
                break;
            default:
                throw new Error('Unknown reasoning strategy');
        }
        this.state.history.push({ type: 'output', value: result });
        return result;
    }

    async reactReasoning(currentInput) {
        let input = currentInput;
        let iteration = 0;
        const maxIterations = 5; // Prevent infinite loops in mock
        console.log("Starting ReAct reasoning...");

        while (!this.isComplete(input) && iteration < maxIterations) {
            const thought = await this.generateThought(input);
            console.log(`ReAct Iteration ${iteration}: Thought - ${thought.newThought}`);
            this.state.history.push({ type: 'thought', value: thought.newThought });

            const action = await this.selectAction(thought);
            console(`ReAct Iteration ${iteration}: Action - ${action.actionType}, Query: ${action.query}`);
            this.state.history.push({ type: 'action', value: action });

            input = await this.executeAction(action);
            console.log(`ReAct Iteration ${iteration}: Observation - ${input.result}`);
            this.state.history.push({ type: 'observation', value: input.result });
            iteration++;
        }
        console.log("ReAct reasoning complete.");
        return input;
    }

    // Mock functions for ReAct
    async generateThought(input) { 
        return { newThought: `Considering '${input.result || input}'. What's next?` }; 
    }
    async selectAction(thought) { 
        if (thought.newThought.includes('final answer')) {
            return { actionType: 'finish', result: thought.newThought.replace('final answer: ', '') };
        }
        return { actionType: 'search_tool', query: `info on ${thought.newThought}` }; 
    }
    async executeAction(action) { 
        if (action.actionType === 'finish') {
            return { result: action.result };
        }
        return { result: `Executed ${action.actionType} with query '${action.query}'. Result: Data from external source.` }; 
    }
    isComplete(input) { 
        return input.result && input.result.startsWith('final answer:'); 
    }

    async planAndExecute(input) {
        console.log("Starting Plan-and-Execute reasoning...");
        // Step 1: Planning
        const plan = await this.createPlan(input);
        console.log(`Plan generated: ${JSON.stringify(plan.steps)}`);
        this.state.history.push({ type: 'plan', value: plan.steps });

        // Step 2: Execution
        let currentResult = input;
        for (const step of plan.steps) {
            console.log(`Executing plan step: ${step.description}`);
            this.state.history.push({ type: 'plan_step', value: step });
            currentResult = await this.performStep(step, currentResult);
            console.log(`Result after step: ${currentResult}`);
        }
        console.log("Plan-and-Execute reasoning complete.");
        return currentResult;
    }

    // Mock functions for Plan-and-Execute
    async createPlan(input) {
        return {
            steps: [
                { id: 'p1', description: `Understand ${input}`, action: 'read_docs' },
                { id: 'p2', description: `Analyze ${input}`, action: 'analyze_info' },
                { id: 'p3', description: `Synthesize ${input}`, action: 'generate_summary' }
            ]
        };
    }
    async performStep(step, currentResult) {
        await new Promise(resolve => setTimeout(resolve, 50)); // Simulate work
        return `Result of '${step.description}' on '${currentResult}'`;
    }
}

// Example Usage
async function runReasoningAgentExample() {
    console.log("--- ReAct Agent Example ---");
    const reactAgent = new ReasoningAgent('react');
    const reactResult = await reactAgent.think({ content: 'How to make a great coffee?' });
    console.log("Final ReAct Result:", reactResult);
    console.log("ReAct Agent History:", reactAgent.state.history);

    console.log("\n--- Plan-and-Execute Agent Example ---");
    const planExecuteAgent = new ReasoningAgent('plan-and-execute');
    const planExecuteResult = await planExecuteAgent.think('Develop a marketing strategy for a new product.');
    console.log("Final Plan-and-Execute Result:", planExecuteResult);
    console.log("Plan-and-Execute Agent History:", planExecuteAgent.state.history);
}

// Execute the example
if (typeof globalThis.process === 'undefined' || !globalThis.process.versions || !globalThis.process.versions.node) {
    runReasoningAgentExample(); // Browser environment
} else {
    runReasoningAgentExample(); // Node.js environment
}
</code></pre>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
            <i class="fas fa-lightbulb text-green-500"></i> Use Cases
          </h3>
          <ul class="space-y-3 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Decision Support Systems:</strong> Choosing between a reactive (e.g., immediate customer service bot) or planned approach (e.g., complex financial analysis).</li>
            <li><strong class="text-gray-900">Problem-Solving Agents:</strong> Applying ReAct for dynamic, exploratory tasks vs. Plan-and-Execute for well-defined, multi-step engineering problems.</li>
            <li><strong class="text-gray-900">Autonomous Systems:</strong> Designing agents that need to adapt quickly to changing environments (ReAct) versus those requiring meticulous, long-term strategizing (Plan-and-Execute).</li>
            <li><strong class="text-gray-900">Intelligent Automation:</strong> Selecting a reasoning pattern that best fits the predictability and dynamism of the automated process.</li>
          </ul>
        </div>

        <div>
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
            <i class="fas fa-project-diagram text-green-500"></i> Related Patterns
          </h3>
          <ul class="space-y-2 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Planning Pattern:</strong> The core of the Plan-and-Execute reasoning approach.</li>
            <li><strong class="text-gray-900">Reflection Pattern:</strong> Can be used to evaluate the effectiveness of different reasoning strategies and learn which works best in various contexts.</li>
            <li><strong class="text-gray-900">Tool Use Pattern:</strong> Integral to both ReAct (where tools are invoked as actions) and Plan-and-Execute (where tools are part of planned steps).</li>
            <li><strong class="text-gray-900">Prompt Chaining Pattern:</strong> Can implement sequential steps within a reasoning process, particularly for multi-turn dialogues or complex thought processes.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Flexibility vs Structure Section -->
    <section id="flexibility" class="mb-12">
      <div class="mb-8">
        <h2 class="text-3xl font-extrabold section-header-yellow bg-clip-text text-transparent flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-yellow-200">
            <i class="fas fa-random text-yellow-600"></i> Flexibility vs Structure
        </h2>
      </div>
      <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-yellow-100 p-10 mb-10 border border-yellow-200 backdrop-blur-sm">
        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
            <i class="fas fa-info-circle text-yellow-500"></i> Description
          </h3>
          <p class="text-gray-700 leading-relaxed">This pattern explores the <strong>inherent trade-offs and dynamic balance</strong> between flexibility and structure in agentic system design. It analyzes how different architectural choices influence an agent's ability to adapt to unforeseen circumstances (flexibility) versus its adherence to predefined workflows and predictability (structure), ultimately impacting reliability and maintainability.</p>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
            <i class="fas fa-puzzle-piece text-yellow-500"></i> Key Components
          </h3>
          <ul class="space-y-4 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Adaptability Mechanisms:</strong> Design elements that allow an agent to deviate from a rigid path (e.g., dynamic routing, error recovery).</li>
            <li><strong class="text-gray-900">Structure Enforcement:</strong> Components that ensure adherence to predefined rules, plans, or sequences for predictability (e.g., strict planning, validation steps).</li>
            <li><strong class="text-gray-900">Balance Management:</strong> Strategies to determine when to prioritize flexibility over structure, or vice versa, based on context.</li>
            <li><strong class="text-gray-900">State Transitions:</strong> Logic for an agent to shift between more flexible and more structured modes of operation.</li>
          </ul>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
            <i class="fas fa-code text-yellow-500"></i> Implementation
          </h3>
          <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>class AdaptiveSystem {
    constructor(config) {
        this.flexibilityLevel = config.flexibilityLevel; // e.g., 0.8 for high flexibility
        this.structureLevel = config.structureLevel;   // e.g., 0.2 for low structure
        this.flexibilityThreshold = config.flexibilityThreshold || 0.5; // Threshold for switching behavior
        console.log(`AdaptiveSystem initialized: Flexibility=${this.flexibilityLevel}, Structure=${this.structureLevel}`);
    }

    async handleRequest(request) {
        console.log(`Handling request with uncertainty: ${request.uncertainty}`);
        if (this.requiresFlexibility(request)) {
            console.log("--> Request requires flexibility. Handling with flexible approach...");
            return this.flexibleHandler(request);
        } else {
            console.log("--> Request is straightforward. Handling with structured approach...");
            return this.structuredHandler(request);
        }
    }

    requiresFlexibility(request) {
        // Example logic: if uncertainty in request is above a threshold, requires flexibility
        return request.uncertainty > this.flexibilityThreshold;
    }

    async flexibleHandler(request) {
        // Simulate a flexible, adaptive process (e.g., using LLM for dynamic problem-solving)
        await new Promise(resolve => setTimeout(resolve, 150));
        const dynamicResult = `Dynamically handled: ${request.query}. Adapting to new info.`;
        return { status: 'flexible_handled', data: { query: request.query, result: dynamicResult } };
    }

    async structuredHandler(request) {
        // Simulate a structured, predefined process (e.g., rule-based or fixed pipeline)
        await new Promise(resolve => setTimeout(resolve, 50));
        const fixedResult = `Structuredly handled: ${request.query}. Following standard procedure.`;
        return { status: 'structured_handled', data: { query: request.query, result: fixedResult } };
    }
}

// Example Usage
async function runAdaptiveSystemExample() {
    console.log("Starting AdaptiveSystem Example...");
    const system = new AdaptiveSystem({ flexibilityLevel: 0.7, structureLevel: 0.3, flexibilityThreshold: 0.6 });

    // Scenario 1: High uncertainty request
    const highUncertaintyRequest = { query: 'Solve this ambiguous complex problem.', uncertainty: 0.8 };
    let result = await system.handleRequest(highUncertaintyRequest);
    console.log("Result for High Uncertainty Request:", result);

    console.log("\n");

    // Scenario 2: Low uncertainty request
    const lowUncertaintyRequest = { query: 'Process standard user registration.', uncertainty: 0.3 };
    result = await system.handleRequest(lowUncertaintyRequest);
    console.log("Result for Low Uncertainty Request:", result);
}

// Execute the example
if (typeof globalThis.process === 'undefined' || !globalThis.process.versions || !globalThis.process.versions.node) {
    runAdaptiveSystemExample(); // Browser environment
} else {
    runAdaptiveSystemExample(); // Node.js environment
}
</code></pre>
        </div>

        <div class="mb-10">
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
            <i class="fas fa-lightbulb text-yellow-500"></i> Use Cases
          </h3>
          <ul class="space-y-3 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Adaptive Systems:</strong> Designing agents that can dynamically switch between fixed protocols and exploratory behaviors based on environmental changes.</li>
            <li><strong class="text-gray-900">Hybrid Workflows:</strong> Combining predictable, automated segments with flexible, human-in-the-loop or LLM-driven adaptive segments.</li>
            <li><strong class="text-gray-900">Dynamic Routing:</strong> Using the Routing pattern to direct tasks to highly specialized, structured agents or more general, flexible problem-solving agents.</li>
            <li><strong class="text-gray-900">System Optimization:</strong> Analyzing the performance trade-offs (e.g., speed vs. robustness) when choosing between more flexible or more structured designs for specific tasks.</li>
          </ul>
        </div>

        <div>
          <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
            <i class="fas fa-project-diagram text-yellow-500"></i> Related Patterns
          </h3>
          <ul class="space-y-2 text-gray-700 list-disc list-inside ml-4">
            <li><strong class="text-gray-900">Routing Pattern:</strong> A primary enabler of flexibility, allowing dynamic selection of agents or workflows.</li>
            <li><strong class="text-gray-900">Planning Pattern:</strong> Strongly associated with structure, as it provides a predefined sequence of actions.</li>
            <li><strong class="text-gray-900">Reflection Pattern:</strong> Crucial for evaluating the outcomes of both flexible and structured approaches and fine-tuning the balance.</li>
            <li><strong class="text-gray-900">Tool Use Pattern:</strong> Can support both flexible (dynamic tool selection) and structured (predefined tool sequences) behaviors.</li>
          </ul>
        </div>
      </div>
    </section>
  </div>
  <script src="../js/app.js"></script>
  <!-- Removed ../js/pattern-details.js as its functionality is not explicit or handled by vanilla JS/Tailwind -->
</body>
</html>
