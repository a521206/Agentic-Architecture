<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agentic Core Patterns</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/custom-styles.css">
</head>
<body class="bg-gray-50 text-gray-800">
    <div class="max-w-6xl mx-auto px-4 py-8">
        <!-- Navigation -->
        <div class="flex flex-col md:flex-row justify-between items-center mb-10 gap-3">
            <a href="agentic-design-pattern.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 font-semibold py-2 px-4 rounded-lg bg-blue-50 hover:bg-blue-100 transition duration-300 shadow-sm border border-blue-200">
                <i class="fas fa-arrow-left mr-2"></i> Previous: Design Patterns
            </a>
            <a href="../../index.html" class="inline-flex items-center text-gray-700 hover:text-blue-700 font-semibold py-2 px-4 rounded-lg bg-gray-100 hover:bg-gray-200 transition duration-300 shadow-sm border border-gray-300">
                <i class="fas fa-home mr-2"></i> Home
            </a>
            <a href="agentic-workflow-patterns.html" class="inline-flex items-center text-blue-600 hover:text-blue-800 font-semibold py-2 px-4 rounded-lg bg-blue-50 hover:bg-blue-100 transition duration-300 shadow-sm border border-blue-200">
                Next: Workflow <i class="fas fa-arrow-right ml-2"></i>
            </a>
        </div>
        
        <header class="header-gradient rounded-3xl shadow-2xl p-12 mb-16 text-center border border-blue-300 transform transition-all duration-500 hover:scale-[1.01] hover:shadow-3xl">
            <h1 class="text-5xl md:text-6xl font-extrabold text-blue-900 mb-5 tracking-tight drop-shadow-lg leading-tight">Agentic Core Patterns</h1>
            <p class="text-2xl text-blue-700 font-medium opacity-90">Foundation patterns for building robust agentic systems</p>
        </header>

        <!-- Pattern Navigation Tiles -->
        <nav class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-8 mb-16">
            <a href="#prompt-chaining" class="bg-gradient-to-br from-blue-50 to-blue-100 hover:from-blue-100 hover:to-blue-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center shadow-lg ring-1 ring-blue-200 hover:ring-blue-300 transform hover:scale-105">
                <div class="text-5xl text-blue-600 mb-3"><i class="fas fa-link"></i></div>
                <h3 class="font-extrabold text-xl mb-2 text-blue-800 text-center">Prompt Chaining</h3>
                <p class="text-gray-600 text-center text-sm">Sequential task decomposition for complex workflows</p>
            </a>
            <a href="#routing" class="bg-gradient-to-br from-purple-50 to-purple-100 hover:from-purple-100 hover:to-purple-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center shadow-lg ring-1 ring-purple-200 hover:ring-purple-300 transform hover:scale-105">
                <div class="text-5xl text-purple-600 mb-3"><i class="fas fa-route"></i></div>
                <h3 class="font-extrabold text-xl mb-2 text-purple-800 text-center">Routing</h3>
                <p class="text-gray-600 text-center text-sm">Intelligent input direction to specialized sub-agents</p>
            </a>
            <a href="#parallelization" class="bg-gradient-to-br from-green-50 to-green-100 hover:from-green-100 hover:to-green-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center shadow-lg ring-1 ring-green-200 hover:ring-green-300 transform hover:scale-105">
                <div class="text-5xl text-green-600 mb-3"><i class="fas fa-code-branch"></i></div>
                <h3 class="font-extrabold text-xl mb-2 text-green-800 text-center">Parallelization</h3>
                <p class="text-gray-600 text-center text-sm">Concurrent task execution for improved efficiency</p>
            </a>
            <a href="#reflection" class="bg-gradient-to-br from-yellow-50 to-yellow-100 hover:from-yellow-100 hover:to-yellow-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center shadow-lg ring-1 ring-yellow-200 hover:ring-yellow-300 transform hover:scale-105">
                <div class="text-5xl text-yellow-600 mb-3"><i class="fas fa-brain"></i></div>
                <h3 class="font-extrabold text-xl mb-2 text-yellow-800 text-center">Reflection</h3>
                <p class="text-gray-600 text-center text-sm">Self-evaluation and continuous improvement</p>
            </a>
            <a href="#planning" class="bg-gradient-to-br from-pink-50 to-pink-100 hover:from-pink-100 hover:to-pink-200 transition-all duration-300 rounded-2xl p-8 flex flex-col items-center shadow-lg ring-1 ring-pink-200 hover:ring-pink-300 transform hover:scale-105">
                <div class="text-5xl text-pink-600 mb-3"><i class="fas fa-project-diagram"></i></div>
                <h3 class="font-extrabold text-xl mb-2 text-pink-800 text-center">Planning</h3>
                <p class="text-gray-600 text-center text-sm">Goal-oriented task structuring and sequencing</p>
            </a>
        </nav>

        <!-- Prompt Chaining Section -->
        <section id="prompt-chaining" class="mb-20">
            <div class="mb-8">
                <h2 class="text-4xl font-extrabold section-header-gradient flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-blue-200">
                    <i class="fas fa-link text-blue-600"></i> Prompt Chaining
                </h2>
            </div>
            <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-blue-100 p-10 mb-10 border border-blue-200">
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
                        <i class="fas fa-info-circle text-blue-500"></i> Description
                    </h3>
                    <p class="text-gray-700 leading-relaxed mb-4">Prompt Chaining is a pattern that breaks down complex tasks into a sequence of smaller, focused prompts. Each prompt in the chain builds upon the results of previous prompts, creating a structured flow of information and reasoning. This pattern is particularly useful for complex tasks that require multiple steps of processing or reasoning.</p>
                    <p class="text-gray-700 leading-relaxed mt-2">There are several approaches to implementing prompt chaining:</p>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-2">
                        <li><span class="font-bold text-gray-800">Sequential Chains:</span> Linear sequence of prompts where each step depends on the previous one.</li>
                        <li><span class="font-bold text-gray-800">Conditional Chains:</span> Branches based on intermediate results or conditions.</li>
                        <li><span class="font-bold text-gray-800">DSPy Modules:</span> Stanford's DSPy provides a declarative way to compose complex chains with automatic optimization. <a href="https://github.com/stanfordnlp/dspy" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Read about DSPy</a>.</li>
                        <li><span class="font-bold text-gray-800">LangChain Sequential Chains:</span> LangChain's implementation of sequential prompt chains with built-in memory and state management. <a href="https://python.langchain.com/docs/modules/chains/" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Read about LangChain Chains</a>.</li>
                    </ul>
                </div>
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
                        <i class="fas fa-code text-blue-500"></i> Implementation using DSPy
                    </h3>
                    <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>import dspy
from dspy.teleprompt import BootstrapFewShot
from dspy.evaluate import Evaluate
from typing import List, Dict

# Define the signature for our chain
class ResearchChain(dspy.Signature):
    """Research a topic and generate a summary."""
    topic: str = dspy.InputField()
    research: str = dspy.OutputField(desc="Research findings")
    summary: str = dspy.OutputField(desc="Concise summary")

# Define the modules in our chain
class ResearchModule(dspy.Module):
    def __init__(self):
        super().__init__()
        self.research = dspy.ChainOfThought("topic -> research")
    
    def forward(self, topic: str) -> str:
        return self.research(topic=topic)

class SummaryModule(dspy.Module):
    def __init__(self):
        super().__init__()
        self.summarize = dspy.ChainOfThought("research -> summary")
    
    def forward(self, research: str) -> str:
        return self.summarize(research=research)

# Compose the chain
class ResearchPipeline(dspy.Module):
    def __init__(self):
        super().__init__()
        self.research = ResearchModule()
        self.summarize = SummaryModule()
    
    def forward(self, topic: str) -> Dict[str, str]:
        research = self.research(topic)
        summary = self.summarize(research)
        return {"research": research, "summary": summary}

# Example usage
if __name__ == "__main__":
    # Configure DSPy
    dspy.configure(lm=dspy.OpenAI())
    
    # Create and compile the pipeline
    pipeline = ResearchPipeline()
    
    # Example topics
    topics = [
        "The impact of AI on healthcare",
        "Sustainable energy solutions",
        "Future of remote work"
    ]
    
    # Process each topic
    for topic in topics:
        print(f"\nResearching: {topic}")
        result = pipeline(topic)
        print(f"Research: {result['research']}")
        print(f"Summary: {result['summary']}")</code></pre>
                </div>
                <div>
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-blue-700">
                        <i class="fas fa-lightbulb text-blue-500"></i> Use Cases
                    </h3>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-3">
                        <li class="mb-2"><span class="font-bold text-gray-800">Research and Analysis:</span> Break down complex research tasks into sequential steps: data gathering, analysis, and synthesis. This enables systematic processing of information and generation of comprehensive reports. <a href="https://www.analyticsvidhya.com/blog/2023/12/research-chains/" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Read about Research Chains</a></li>
                        <li class="mb-2"><span class="font-bold text-gray-800">Content Generation:</span> Create structured content generation pipelines for articles, reports, or documentation. This allows for consistent quality and style across different content types. <a href="https://www.datacamp.com/blog/content-generation-chains" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Learn about Content Generation</a></li>
                        <li class="mb-2"><span class="font-bold text-gray-800">Code Generation:</span> Implement multi-step code generation with planning, implementation, and testing phases. This ensures high-quality, well-structured code output. <a href="https://blog.langchain.dev/code-generation-chains/" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Explore Code Generation</a></li>
                        <li class="mb-2"><span class="font-bold text-gray-800">Data Processing:</span> Create pipelines for data cleaning, transformation, and analysis. This enables systematic processing of complex datasets. <a href="https://www.analyticsvidhya.com/blog/2023/12/data-processing-chains/" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Read about Data Processing</a></li>
                        <li class="mb-2"><span class="font-bold text-gray-800">Decision Support:</span> Build decision-making systems that break down complex decisions into logical steps. This enables transparent and explainable decision processes. <a href="https://www.datacamp.com/blog/decision-support-chains" target="_blank" class="underline text-blue-600 hover:text-blue-800 transition-colors duration-200">Learn about Decision Support</a></li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Routing Section -->
        <section id="routing" class="mb-20">
            <div class="mb-8">
                <h2 class="text-4xl font-extrabold section-header-gradient flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-purple-200">
                    <i class="fas fa-route text-purple-600"></i> Routing
                </h2>
            </div>
            <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-purple-100 p-10 mb-10 border border-purple-200">
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
                        <i class="fas fa-info-circle text-purple-500"></i> Description
                    </h3>
                    <p class="text-gray-700 leading-relaxed mb-4">Routing is a pattern that directs inputs to different specialized agents or chains based on their content or purpose. It's like a traffic controller for AI agents, ensuring each query reaches the most appropriate handler. This pattern is particularly useful when you have multiple specialized agents and need to determine which one should handle a particular request.</p>
                    <p class="text-gray-700 leading-relaxed mt-2">There are several approaches to implementing routing:</p>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-2">
                        <li><span class="font-bold text-gray-800">Rule-based Routing:</span> Uses predefined rules or conditions to direct inputs to specific handlers.</li>
                        <li><span class="font-bold text-gray-800">LLM-based Classification:</span> Uses a language model to analyze the input and determine the appropriate handler.</li>
                        <li><span class="font-bold text-gray-800">LangChain Router Chains:</span> LangChain provides specific router chains that use an LLM to classify an input and choose the next chain to execute. <a href="https://python.langchain.com/docs/modules/chains/router" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Read about LangChain Routers</a>.</li>
                        <li><span class="font-bold text-gray-800">OpenAI Function Calling:</span> While primarily for tool use, the underlying mechanism of choosing which function to call based on a prompt is a form of routing. <a href="https://platform.openai.com/docs/guides/function-calling" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Read about OpenAI Function Calling</a>.</li>
                    </ul>
                </div>
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
                        <i class="fas fa-code text-purple-500"></i> Implementation using LangGraph
                    </h3>
                    <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>from typing import Dict, List, Any, TypedDict, Annotated
from langchain_core.messages import BaseMessage, HumanMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import tool

# Define tools for each agent
@tool
def check_order_status(order_id: str) -> str:
    """Check the status of an order."""
    return f"Order {order_id} is in transit"

@tool
def get_product_info(product: str) -> str:
    """Get information about a product."""
    return f"Product {product} is available in stock"

# Create specialized agents
def create_agent(name: str, system_prompt: str, tools: List = None):
    llm = ChatOpenAI(temperature=0)
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        MessagesPlaceholder(variable_name="messages"),
        MessagesPlaceholder(variable_name="agent_scratchpad")
    ])
    return create_openai_functions_agent(llm, tools or [], prompt)

# Create the supervisor agent
supervisor = create_agent(
    "supervisor",
    """You are a supervisor agent that routes queries to specialized agents.
    Choose the most appropriate agent based on the query content.
    Available agents: customer_support, order_status, product_info""",
    [check_order_status, get_product_info]
)

# Create specialized agents
agents = {
    "customer_support": create_agent(
        "customer_support",
        "You are a customer support agent. Help customers with their inquiries.",
        [check_order_status, get_product_info]
    ),
    "order_status": create_agent(
        "order_status",
        "You are an order status specialist. Help customers track their orders.",
        [check_order_status]
    ),
    "product_info": create_agent(
        "product_info",
        "You are a product specialist. Provide detailed product information.",
        [get_product_info]
    )
}

# Create the workflow
def create_workflow():
    # Define the state
    class AgentState(TypedDict):
        messages: List[BaseMessage]
        next: str
        agent_scratchpad: List[BaseMessage]

    # Create the graph
    workflow = StateGraph(AgentState)
    
    # Add nodes for each agent
    for name, agent in agents.items():
        workflow.add_node(name, AgentExecutor(agent=agent, tools=agent.tools))
    
    # Add supervisor node
    workflow.add_node("supervisor", AgentExecutor(agent=supervisor, tools=supervisor.tools))
    
    # Define the router
    def router(state: AgentState) -> str:
        if not state["messages"]:
            return END
        return state["next"] or "supervisor"
    
    # Add edges
    workflow.add_conditional_edges(
        "supervisor",
        router,
        {name: name for name in agents.keys()} | {END: END}
    )
    
    for name in agents.keys():
        workflow.add_edge(name, "supervisor")
    
    workflow.set_entry_point("supervisor")
    return workflow.compile()

# Example usage
if __name__ == "__main__":
    app = create_workflow()
    
    # Example queries
    queries = [
        "What's the status of order #12345?",
        "Tell me about the new iPhone features",
        "I need help with a return"
    ]
    
    for query in queries:
        print(f"\nProcessing: {query}")
        result = app.invoke({
            "messages": [HumanMessage(content=query)],
            "next": "",
            "agent_scratchpad": []
        })
        print(f"Response: {result['messages'][-1].content}")</code></pre>
                </div>

                <div>
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-purple-700">
                        <i class="fas fa-lightbulb text-purple-500"></i> Use Cases
                    </h3>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-3">
                        <li>
                            <strong>Customer Service Automation</strong>
                            <p class="mb-1">Route customer inquiries to specialized agents based on query type (billing, technical support, product information). This ensures each query is handled by the most appropriate agent, improving response quality and efficiency.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/agent-routing/" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Read about Customer Service Routing</a>
                        </li>
                        <li>
                            <strong>Content Moderation</strong>
                            <p class="mb-1">Direct content to different moderation agents based on content type and risk level. This enables efficient content screening and appropriate handling of different types of content violations.</p>
                            <a href="https://www.datacamp.com/blog/ai-content-moderation" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Learn about AI Content Moderation</a>
                        </li>
                        <li>
                            <strong>Multi-Agent Workflows</strong>
                            <p class="mb-1">Coordinate complex tasks across multiple specialized agents. This allows for sophisticated problem-solving by leveraging the strengths of different agents in a coordinated manner.</p>
                            <a href="https://blog.langchain.dev/langgraph-multi-agent-workflows/" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Explore Multi-Agent Workflows</a>
                        </li>
                        <li>
                            <strong>Document Processing</strong>
                            <p class="mb-1">Route documents to appropriate processing agents based on document type and content. This enables efficient handling of different document formats and processing requirements.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/document-processing-agents/" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Read about Document Processing</a>
                        </li>
                        <li>
                            <strong>API Gateway</strong>
                            <p class="mb-1">Route API requests to appropriate microservices or handlers based on request type and parameters. This enables efficient request handling and load distribution across services.</p>
                            <a href="https://www.datacamp.com/blog/ai-api-gateway" target="_blank" class="underline text-purple-600 hover:text-purple-800 transition-colors duration-200">Learn about AI API Gateway</a>
                        </li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Parallelization Section -->
        <section id="parallelization" class="mb-20">
            <div class="mb-8">
                <h2 class="text-4xl font-extrabold section-header-gradient flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-green-200">
                    <i class="fas fa-code-branch text-green-600"></i> Parallelization
                </h2>
            </div>
            <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-green-100 p-10 mb-10 border border-green-200">
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
                        <i class="fas fa-info-circle text-green-500"></i> Description
                    </h3>
                    <p class="text-gray-700 leading-relaxed mb-4">Parallelization is a pattern that enables concurrent execution of multiple tasks or agents, significantly improving performance and throughput. This pattern is particularly useful for tasks that can be executed independently or when dealing with multiple data sources or processing streams.</p>
                    <p class="text-gray-700 leading-relaxed mt-2">There are several approaches to implementing parallelization:</p>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-2">
                        <li><span class="font-bold text-gray-800">Async/Await:</span> Python's asyncio for concurrent execution of I/O-bound tasks.</li>
                        <li><span class="font-bold text-gray-800">Threading:</span> For CPU-bound tasks that can benefit from parallel execution.</li>
                        <li><span class="font-bold text-gray-800">Process Pooling:</span> For true parallel execution across multiple CPU cores.</li>
                        <li><span class="font-bold text-gray-800">Distributed Processing:</span> For scaling across multiple machines or services.</li>
                    </ul>
                </div>
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
                        <i class="fas fa-code text-green-500"></i> Implementation using asyncio and ProcessPoolExecutor
                    </h3>
                    <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>import asyncio
from typing import List, Dict, Any
from concurrent.futures import ProcessPoolExecutor
from dataclasses import dataclass
from openai import AsyncOpenAI
import time

@dataclass
class Task:
    """Represents a task to be processed."""
    id: str
    content: str
    priority: int = 1

class ParallelProcessor:
    def __init__(self, api_key: str, max_workers: int = 4):
        self.client = AsyncOpenAI(api_key=api_key)
        self.max_workers = max_workers
        self.process_pool = ProcessPoolExecutor(max_workers=max_workers)
    
    async def process_task(self, task: Task) -> Dict[str, Any]:
        """Process a single task asynchronously."""
        try:
            # Simulate different processing times based on priority
            await asyncio.sleep(1 / task.priority)
            
            # Process the task using OpenAI
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[{"role": "user", "content": task.content}]
            )
            
            return {
                "task_id": task.id,
                "result": response.choices[0].message.content,
                "status": "completed"
            }
        except Exception as e:
            return {
                "task_id": task.id,
                "error": str(e),
                "status": "failed"
            }
    
    async def process_batch(self, tasks: List[Task]) -> List[Dict[str, Any]]:
        """Process multiple tasks concurrently."""
        # Create tasks for concurrent execution
        async_tasks = [self.process_task(task) for task in tasks]
        
        # Execute tasks concurrently and gather results
        results = await asyncio.gather(*async_tasks)
        return results
    
    def process_cpu_bound(self, data: List[Any]) -> List[Any]:
        """Process CPU-bound tasks using process pool."""
        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:
            results = list(executor.map(self._cpu_bound_task, data))
        return results
    
    def _cpu_bound_task(self, data: Any) -> Any:
        """Example CPU-bound task."""
        # Simulate CPU-intensive processing
        time.sleep(0.1)
        return data * 2

async def main():
    # Initialize processor
    processor = ParallelProcessor(api_key="your-api-key")
    
    # Example tasks
    tasks = [
        Task("1", "Analyze this text: AI is transforming industries", 2),
        Task("2", "Summarize: Machine learning applications", 1),
        Task("3", "Generate ideas for: Future of work", 3),
        Task("4", "Evaluate: Impact of automation", 2)
    ]
    
    # Process tasks concurrently
    print("Processing tasks concurrently...")
    start_time = time.time()
    results = await processor.process_batch(tasks)
    end_time = time.time()
    
    print(f"\nProcessed {len(results)} tasks in {end_time - start_time:.2f} seconds")
    for result in results:
        print(f"\nTask {result['task_id']}:")
        print(f"Status: {result['status']}")
        if result['status'] == 'completed':
            print(f"Result: {result['result']}")
        else:
            print(f"Error: {result['error']}")
    
    # Example of CPU-bound processing
    print("\nProcessing CPU-bound tasks...")
    data = list(range(10))
    results = processor.process_cpu_bound(data)
    print(f"Results: {results}")

if __name__ == "__main__":
    asyncio.run(main())</code></pre>
                </div>
                <div>
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-green-700">
                        <i class="fas fa-lightbulb text-green-500"></i> Use Cases
                    </h3>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-3">
                        <li>
                            <strong>Data Processing Pipelines</strong>
                            <p class="mb-1">Process large datasets concurrently by splitting them into chunks and processing them in parallel. This significantly reduces processing time for large-scale data operations.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/parallel-data-processing/" target="_blank" class="underline text-green-600 hover:text-green-800 transition-colors duration-200">Read about Parallel Data Processing</a>
                        </li>
                        <li>
                            <strong>API Integration</strong>
                            <p class="mb-1">Make multiple API calls concurrently to different services. This improves response times when integrating with multiple external systems.</p>
                            <a href="https://www.datacamp.com/blog/async-api-integration" target="_blank" class="underline text-green-600 hover:text-green-800 transition-colors duration-200">Learn about Async API Integration</a>
                        </li>
                        <li>
                            <strong>Content Generation</strong>
                            <p class="mb-1">Generate multiple content pieces simultaneously. This enables efficient creation of large content sets while maintaining quality.</p>
                            <a href="https://blog.langchain.dev/parallel-content-generation/" target="_blank" class="underline text-green-600 hover:text-green-800 transition-colors duration-200">Explore Parallel Content Generation</a>
                        </li>
                        <li>
                            <strong>Model Training</strong>
                            <p class="mb-1">Train multiple models or hyperparameter combinations in parallel. This accelerates the model development and optimization process.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/parallel-model-training/" target="_blank" class="underline text-green-600 hover:text-green-800 transition-colors duration-200">Read about Parallel Model Training</a>
                        </li>
                        <li>
                            <strong>Real-time Analytics</strong>
                            <p class="mb-1">Process multiple data streams concurrently for real-time analysis. This enables immediate insights from multiple data sources.</p>
                            <a href="https://www.datacamp.com/blog/real-time-analytics" target="_blank" class="underline text-green-600 hover:text-green-800 transition-colors duration-200">Learn about Real-time Analytics</a>
                        </li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Reflection Section -->
        <section id="reflection" class="mb-20">
            <div class="mb-8">
                <h2 class="text-4xl font-extrabold section-header-gradient flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-yellow-200">
                    <i class="fas fa-brain text-yellow-600"></i> Reflection
                </h2>
            </div>
            <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-yellow-100 p-10 mb-10 border border-yellow-200">
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
                        <i class="fas fa-info-circle text-yellow-500"></i> Description
                    </h3>
                    <p class="text-gray-700 leading-relaxed mb-4">Reflection is a pattern that enables AI agents to evaluate their own performance, learn from past experiences, and improve their future actions. This pattern is crucial for building self-improving systems that can adapt to new situations and optimize their behavior over time.</p>
                    <p class="text-gray-700 leading-relaxed mt-2">There are several approaches to implementing reflection:</p>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-2">
                        <li><span class="font-bold text-gray-800">Self-Evaluation:</span> Agents analyze their own outputs and decisions for quality and correctness.</li>
                        <li><span class="font-bold text-gray-800">Feedback Integration:</span> Incorporate external feedback to improve future responses.</li>
                        <li><span class="font-bold text-gray-800">Memory-Based Learning:</span> Store and learn from past interactions and outcomes.</li>
                        <li><span class="font-bold text-gray-800">Meta-Cognitive Analysis:</span> Evaluate the reasoning process and decision-making strategies.</li>
                    </ul>
                </div>
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
                        <i class="fas fa-code text-yellow-500"></i> Implementation using OpenAI API
                    </h3>
                    <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
from openai import OpenAI
import json

@dataclass
class Reflection:
    """Represents a reflection on a task or interaction."""
    task_id: str
    original_output: str
    evaluation: Dict[str, Any]
    improvements: List[str]
    timestamp: datetime = datetime.now()

class ReflectiveAgent:
    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)
        self.memory: List[Reflection] = []
    
    def _evaluate_output(self, task: str, output: str) -> Dict[str, Any]:
        """Evaluate the quality and correctness of an output."""
        prompt = f"""Evaluate the following output for the task: {task}

Output: {output}

Provide a detailed evaluation in JSON format with the following structure:
{{
    "accuracy": float,  # 0-1 score
    "completeness": float,  # 0-1 score
    "relevance": float,  # 0-1 score
    "strengths": [string],
    "weaknesses": [string]
}}"""

        response = self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"}
        )
        
        return json.loads(response.choices[0].message.content)
    
    def _generate_improvements(self, task: str, output: str, evaluation: Dict[str, Any]) -> List[str]:
        """Generate specific improvements based on evaluation."""
        prompt = f"""Based on the following evaluation, suggest specific improvements for the output:

Task: {task}
Output: {output}
Evaluation: {json.dumps(evaluation, indent=2)}

Provide a list of concrete improvements in JSON format:
{{
    "improvements": [string]
}}"""

        response = self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"}
        )
        
        return json.loads(response.choices[0].message.content)["improvements"]
    
    def _apply_improvements(self, task: str, output: str, improvements: List[str]) -> str:
        """Apply the suggested improvements to the output."""
        prompt = f"""Improve the following output based on these suggestions:

Task: {task}
Original Output: {output}
Improvements: {json.dumps(improvements, indent=2)}

Provide an improved version of the output that addresses all the suggestions."""

        response = self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content
    
    def process_with_reflection(self, task: str, initial_output: str) -> Dict[str, Any]:
        """Process a task with reflection and improvement."""
        # Evaluate the output
        evaluation = self._evaluate_output(task, initial_output)
        
        # Generate improvements
        improvements = self._generate_improvements(task, initial_output, evaluation)
        
        # Apply improvements
        improved_output = self._apply_improvements(task, initial_output, improvements)
        
        # Store reflection
        reflection = Reflection(
            task_id=task,
            original_output=initial_output,
            evaluation=evaluation,
            improvements=improvements
        )
        self.memory.append(reflection)
        
        return {
            "original_output": initial_output,
            "evaluation": evaluation,
            "improvements": improvements,
            "improved_output": improved_output
        }
    
    def get_learning_insights(self) -> Dict[str, Any]:
        """Analyze past reflections to generate learning insights."""
        if not self.memory:
            return {"message": "No reflections available for analysis"}
        
        # Prepare reflection history
        history = "\n".join([
            f"Task: {r.task_id}\n"
            f"Evaluation: {json.dumps(r.evaluation, indent=2)}\n"
            f"Improvements: {json.dumps(r.improvements, indent=2)}\n"
            for r in self.memory[-5:]  # Analyze last 5 reflections
        ])
        
        prompt = f"""Analyze the following reflection history and provide insights:

{history}

Provide insights in JSON format:
{{
    "common_improvements": [string],
    "performance_trends": [string],
    "recommendations": [string]
}}"""

        response = self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"}
        )
        
        return json.loads(response.choices[0].message.content)

# Example usage
if __name__ == "__main__":
    agent = ReflectiveAgent(api_key="your-api-key")
    
    # Example task
    task = "Explain the concept of machine learning to a beginner"
    initial_output = """Machine learning is when computers learn from data. They can make predictions and decisions without being explicitly programmed."""
    
    # Process with reflection
    result = agent.process_with_reflection(task, initial_output)
    
    print("Original Output:", result["original_output"])
    print("\nEvaluation:", json.dumps(result["evaluation"], indent=2))
    print("\nImprovements:", json.dumps(result["improvements"], indent=2))
    print("\nImproved Output:", result["improved_output"])
    
    # Get learning insights
    insights = agent.get_learning_insights()
    print("\nLearning Insights:", json.dumps(insights, indent=2))</code></pre>
                </div>
                <div>
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-yellow-700">
                        <i class="fas fa-lightbulb text-yellow-500"></i> Use Cases
                    </h3>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-3">
                        <li>
                            <strong>Content Quality Assurance</strong>
                            <p class="mb-1">Automatically evaluate and improve content quality through self-reflection. This ensures consistent high-quality output across all generated content.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/ai-content-quality/" target="_blank" class="underline text-yellow-600 hover:text-yellow-800 transition-colors duration-200">Read about Content Quality</a>
                        </li>
                        <li>
                            <strong>Code Review and Improvement</strong>
                            <p class="mb-1">Enable AI to review and improve its own code generation. This leads to more robust and maintainable code output.</p>
                            <a href="https://www.datacamp.com/blog/ai-code-review" target="_blank" class="underline text-yellow-600 hover:text-yellow-800 transition-colors duration-200">Learn about AI Code Review</a>
                        </li>
                        <li>
                            <strong>Learning Systems</strong>
                            <p class="mb-1">Build systems that learn from their mistakes and improve over time. This enables continuous improvement in performance and accuracy.</p>
                            <a href="https://blog.langchain.dev/learning-systems/" target="_blank" class="underline text-yellow-600 hover:text-yellow-800 transition-colors duration-200">Explore Learning Systems</a>
                        </li>
                        <li>
                            <strong>Quality Control</strong>
                            <p class="mb-1">Implement automated quality control through self-evaluation. This ensures consistent quality across all outputs.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/ai-quality-control/" target="_blank" class="underline text-yellow-600 hover:text-yellow-800 transition-colors duration-200">Read about Quality Control</a>
                        </li>
                        <li>
                            <strong>Performance Optimization</strong>
                            <p class="mb-1">Continuously optimize system performance through reflection and improvement. This leads to better efficiency and effectiveness.</p>
                            <a href="https://www.datacamp.com/blog/ai-performance" target="_blank" class="underline text-yellow-600 hover:text-yellow-800 transition-colors duration-200">Learn about Performance Optimization</a>
                        </li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Planning Section -->
        <section id="planning" class="mb-20">
            <div class="mb-8">
                <h2 class="text-4xl font-extrabold section-header-gradient flex items-center gap-3 drop-shadow-md pb-2 border-b-2 border-pink-200">
                    <i class="fas fa-project-diagram text-pink-600"></i> Planning
                </h2>
            </div>
            <div class="content-block-bg rounded-3xl shadow-xl ring-2 ring-pink-100 p-10 mb-10 border border-pink-200">
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-pink-700">
                        <i class="fas fa-info-circle text-pink-500"></i> Description
                    </h3>
                    <p class="text-gray-700 leading-relaxed mb-4">Planning is a pattern that enables AI agents to create and execute sequences of actions to achieve specific goals. By breaking down complex tasks into manageable steps and considering dependencies and constraints, this pattern enables systematic problem-solving and goal achievement.</p>
                    <p class="text-gray-700 leading-relaxed mt-2">There are several approaches to implementing planning systems:</p>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-2">
                        <li><span class="font-bold text-gray-800">Hierarchical Planning:</span> Breaking down goals into sub-goals and creating hierarchical action plans.</li>
                        <li><span class="font-bold text-gray-800">Reactive Planning:</span> Adapting plans based on real-time feedback and changing conditions.</li>
                        <li><span class="font-bold text-gray-800">Constraint-Based Planning:</span> Considering various constraints and dependencies while creating plans.</li>
                        <li><span class="font-bold text-gray-800">Goal-Oriented Planning:</span> Focusing on achieving specific goals through systematic action sequences.</li>
                    </ul>
                </div>
                <div class="mb-10">
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-pink-700">
                        <i class="fas fa-code text-pink-500"></i> Implementation using OpenAI API and NetworkX
                    </h3>
                    <pre class="bg-gray-900 text-gray-100 rounded-xl p-6 overflow-x-auto text-sm font-mono shadow-inner border border-gray-700"><code>from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass
from openai import OpenAI
import json
from datetime import datetime
import networkx as nx

@dataclass
class Action:
    """Represents a single action in a plan."""
    name: str
    description: str
    prerequisites: Set[str]
    effects: Set[str]
    duration: int  # in minutes
    resources: Dict[str, Any]

@dataclass
class Goal:
    """Represents a goal to be achieved."""
    name: str
    description: str
    conditions: Set[str]
    priority: int

class Planner:
    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)
        self.actions: Dict[str, Action] = {}
        self.goals: List[Goal] = []
        self.plan_graph = nx.DiGraph()
    
    def add_action(self, action: Action):
        """Add an action to the planner's knowledge base."""
        self.actions[action.name] = action
        self.plan_graph.add_node(action.name, **action.__dict__)
    
    def add_goal(self, goal: Goal):
        """Add a goal to be achieved."""
        self.goals.append(goal)
    
    def _create_action_graph(self) -> nx.DiGraph:
        """Create a graph of actions and their dependencies."""
        graph = nx.DiGraph()
        
        # Add all actions as nodes
        for action in self.actions.values():
            graph.add_node(action.name, **action.__dict__)
        
        # Add edges based on prerequisites and effects
        for action in self.actions.values():
            for prereq in action.prerequisites:
                # Find actions that produce this prerequisite
                for other_action in self.actions.values():
                    if prereq in other_action.effects:
                        graph.add_edge(other_action.name, action.name)
        
        return graph
    
    async def generate_plan(self, initial_state: Set[str]) -> Dict[str, Any]:
        """Generate a plan to achieve the goals from the initial state."""
        # Create action graph
        action_graph = self._create_action_graph()
        
        # Sort goals by priority
        sorted_goals = sorted(self.goals, key=lambda g: g.priority, reverse=True)
        
        # Generate plan for each goal
        plan = []
        current_state = initial_state.copy()
        
        for goal in sorted_goals:
            # Find actions needed to achieve goal
            needed_conditions = goal.conditions - current_state
            if not needed_conditions:
                continue
            
            # Use LLM to select actions
            prompt = f"""Given the following:
Current state: {current_state}
Needed conditions: {needed_conditions}
Available actions: {json.dumps([a.__dict__ for a in self.actions.values()], indent=2)}

Select the best sequence of actions to achieve the needed conditions.
Consider dependencies, resources, and efficiency."""

            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[{"role": "user", "content": prompt}]
            )
            
            # Parse selected actions
            selected_actions = json.loads(response.choices[0].message.content)
            
            # Add actions to plan
            for action_name in selected_actions:
                action = self.actions[action_name]
                plan.append({
                    "action": action_name,
                    "description": action.description,
                    "duration": action.duration,
                    "resources": action.resources
                })
                current_state.update(action.effects)
        
        return {
            "goals": [g.__dict__ for g in sorted_goals],
            "plan": plan,
            "final_state": current_state
        }
    
    async def execute_plan(self, plan: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a generated plan and track progress."""
        execution_log = []
        current_state = set()
        
        for step in plan["plan"]:
            action = self.actions[step["action"]]
            
            # Check prerequisites
            if not action.prerequisites.issubset(current_state):
                execution_log.append({
                    "step": step["action"],
                    "status": "failed",
                    "reason": "Prerequisites not met",
                    "missing": list(action.prerequisites - current_state)
                })
                continue
            
            # Execute action
            execution_log.append({
                "step": step["action"],
                "status": "executed",
                "start_time": datetime.now().isoformat(),
                "duration": step["duration"],
                "resources_used": step["resources"]
            })
            
            # Update state
            current_state.update(action.effects)
        
        return {
            "execution_log": execution_log,
            "final_state": current_state,
            "success": all(log["status"] == "executed" for log in execution_log)
        }

# Example usage
async def main():
    # Initialize planner
    planner = Planner(api_key="your-api-key")
    
    # Define actions
    planner.add_action(Action(
        name="research_market",
        description="Research market conditions and opportunities",
        prerequisites=set(),
        effects={"market_knowledge"},
        duration=120,
        resources={"researcher": 1}
    ))
    
    planner.add_action(Action(
        name="develop_strategy",
        description="Develop business strategy based on market research",
        prerequisites={"market_knowledge"},
        effects={"business_strategy"},
        duration=180,
        resources={"strategist": 1}
    ))
    
    planner.add_action(Action(
        name="create_implementation_plan",
        description="Create detailed implementation plan",
        prerequisites={"business_strategy"},
        effects={"implementation_plan"},
        duration=90,
        resources={"planner": 1}
    ))
    
    # Define goals
    planner.add_goal(Goal(
        name="market_entry",
        description="Successfully enter a new market",
        conditions={"market_knowledge", "business_strategy", "implementation_plan"},
        priority=1
    ))
    
    # Generate and execute plan
    initial_state = set()
    plan = await planner.generate_plan(initial_state)
    print("\nGenerated Plan:")
    print(json.dumps(plan, indent=2))
    
    execution_result = await planner.execute_plan(plan)
    print("\nExecution Result:")
    print(json.dumps(execution_result, indent=2))

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())</code></pre>
                </div>
                <div>
                    <h3 class="font-bold text-2xl mb-4 flex items-center gap-2 text-pink-700">
                        <i class="fas fa-lightbulb text-pink-500"></i> Use Cases
                    </h3>
                    <ul class="list-disc list-inside text-gray-700 ml-6 mt-4 space-y-3">
                        <li>
                            <strong>Project Management</strong>
                            <p class="mb-1">Create and execute project plans with dependencies and resource allocation. This enables efficient project execution and management.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/ai-project-planning/" target="_blank" class="underline text-pink-600 hover:text-pink-800 transition-colors duration-200">Read about AI Project Planning</a>
                        </li>
                        <li>
                            <strong>Resource Optimization</strong>
                            <p class="mb-1">Plan and optimize resource allocation for various tasks. This leads to better resource utilization and cost efficiency.</p>
                            <a href="https://www.datacamp.com/blog/ai-resource-optimization" target="_blank" class="underline text-pink-600 hover:text-pink-800 transition-colors duration-200">Learn about Resource Optimization</a>
                        </li>
                        <li>
                            <strong>Process Automation</strong>
                            <p class="mb-1">Automate complex processes by planning and executing sequences of actions. This enables efficient process automation.</p>
                            <a href="https://blog.langchain.dev/ai-process-automation/" target="_blank" class="underline text-pink-600 hover:text-pink-800 transition-colors duration-200">Explore Process Automation</a>
                        </li>
                        <li>
                            <strong>Strategic Planning</strong>
                            <p class="mb-1">Develop and execute strategic plans for business operations. This enables systematic achievement of business goals.</p>
                            <a href="https://www.analyticsvidhya.com/blog/2023/12/ai-strategic-planning/" target="_blank" class="underline text-pink-600 hover:text-pink-800 transition-colors duration-200">Read about Strategic Planning</a>
                        </li>
                        <li>
                            <strong>Workflow Management</strong>
                            <p class="mb-1">Plan and manage complex workflows with multiple dependencies. This enables efficient workflow execution and management.</p>
                            <a href="https://www.datacamp.com/blog/ai-workflow-management" target="_blank" class="underline text-pink-600 hover:text-pink-800 transition-colors duration-200">Learn about Workflow Management</a>
                        </li>
                    </ul>
                </div>
            </div>
        </section>
    </div>
    <script src="../js/app.js"></script>
</body>
</html>
